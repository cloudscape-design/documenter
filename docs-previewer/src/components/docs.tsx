// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import React, { useEffect, useRef, useState } from 'react';
import { Box, SpaceBetween, Header, Badge, Table, Container, FormField, Select } from '@cloudscape-design/components';
import { Code, CodeToken } from './code';
import Markdown from './markdown';
import PageLayout from './page-layout';
import { useNavigate, Routes, Route, useLocation } from 'react-router-dom';
import { DefinitionEntry } from '../use-docs';

type Definition = any;

interface NodeProps {
  definition: Definition;
  onNavigate: (name: string) => void;
  level: number;
}

export default function Docs({ docs, packageName }: { docs: DefinitionEntry[]; packageName: string }): JSX.Element {
  const navigate = useNavigate();

  const onNavigate = (path: string) => navigate(`/${packageName}/${path}`);
  const uniqueNames = Array.from(new Set(docs.map(it => it.name)));

  return (
    <Routes>
      {uniqueNames.map(name => (
        <Route
          path={`/${name}`}
          key={name}
          element={
            <PageLayout
              header={name}
              breadcrumbs={[
                { text: 'Packages', href: '/' },
                { text: packageName, href: `/${packageName}` },
                { text: name, href: `/${packageName}/${name}` },
              ]}
              navigationHeader={name}
              navigationHeaderHref={'/' + packageName + '/' + name}
              navigationLinks={docs
                .filter(d => d.name === name)
                .map(d => ({
                  type: 'link',
                  text: d.folder,
                  href: `/${packageName}/${name}#${d.folder + '-' + d.name}`,
                }))}
            >
              <Container>
                <SelectedDoc docs={docs} selected={name} onNavigate={onNavigate} />
              </Container>
            </PageLayout>
          }
        />
      ))}

      <Route
        path="/"
        element={
          <PageLayout
            header={packageName}
            breadcrumbs={[
              { text: 'Packages', href: '/' },
              { text: packageName, href: `/${packageName}` },
            ]}
            navigationHeader={packageName}
            navigationHeaderHref={'/' + packageName}
            navigationLinks={uniqueNames.map(name => ({
              type: 'link',
              text: name,
              href: name,
            }))}
          >
            <Container>
              <FormField
                label="Select API"
                description="The list of package's public API elements is generated by documenter."
              >
                <Select
                  selectedOption={null}
                  options={uniqueNames.map(elementName => ({ value: elementName, label: elementName }))}
                  onChange={e =>
                    e.detail.selectedOption.value && navigate('/' + packageName + '/' + e.detail.selectedOption.value)
                  }
                  placeholder="API name"
                />
              </FormField>
            </Container>
          </PageLayout>
        }
      />
    </Routes>
  );
}

function SelectedDoc({
  docs,
  selected,
  onNavigate,
}: {
  docs: DefinitionEntry[];
  selected: string;
  onNavigate: (path: string) => void;
}) {
  const [selectedDocs, selectDocs] = useState<Definition[]>([]);

  useEffect(() => {
    selectDocs(docs.filter(d => d.name === selected));
  }, [docs, selected]);

  return (
    <SpaceBetween size="m">
      {selectedDocs.map((doc, index) => (
        <LayoutNode key={index} definition={doc.definition} onNavigate={onNavigate} level={1} />
      ))}
    </SpaceBetween>
  );
}

function LayoutNode({ definition, onNavigate, level }: NodeProps) {
  switch (definition.nodeType) {
    case 'Section':
      return <SectionNode definition={definition} onNavigate={onNavigate} level={level} />;
    case 'Table':
      return <TableNode definition={definition} onNavigate={onNavigate} level={level} />;
    case 'Title':
      return <TitleNode definition={definition} onNavigate={onNavigate} level={level} />;
    case 'Comment':
      return <CommentNode definition={definition} onNavigate={onNavigate} level={level} />;
    case 'Code':
      return <CodeNode definition={definition} onNavigate={onNavigate} level={level} />;
    case 'Literal':
      return <LiteralNode definition={definition} onNavigate={onNavigate} level={level} />;
    case 'Empty':
      return <EmptyNode />;
    default:
      return null;
  }
}

function SectionNode({ definition, onNavigate, level }: NodeProps) {
  const ref = useRef<HTMLDivElement>(null);
  const location = useLocation();

  const title = <LayoutNode definition={definition.title} onNavigate={onNavigate} level={level} />;
  const anchor = definition.title?.name ?? undefined;
  const heading =
    level === 1 ? (
      <Header variant="h2" id={anchor}>
        {title}
      </Header>
    ) : level === 2 ? (
      <Header variant="h3" id={anchor}>
        {title}
      </Header>
    ) : (
      <Box fontWeight="bold" id={anchor}>
        {title}
      </Box>
    );

  useEffect(() => {
    if ('#' + anchor === location.hash && ref.current) {
      ref.current.scrollIntoView();
    }
  }, [location.hash, anchor]);

  return (
    <div>
      {anchor && level < 3 ? <div ref={ref}>{heading}</div> : heading}

      <SpaceBetween size="m">
        {definition.items.map((item: Definition, index: number) => (
          <LayoutNode key={index} definition={item} onNavigate={onNavigate} level={level + 1} />
        ))}
      </SpaceBetween>
    </div>
  );
}

function TableNode({ definition, onNavigate, level = 1 }: NodeProps) {
  if (definition.items.length === 0) {
    return null;
  }

  const columnDefinitions = definition.header.map((name: string, index: number) => ({
    id: name,
    header: name,
    cell: (row: any) => <LayoutNode definition={row[index]} onNavigate={onNavigate} level={level + 1} />,
  }));

  return (
    <Table
      variant="embedded"
      header={<Header>{definition.title}</Header>}
      items={definition.items}
      columnDefinitions={columnDefinitions}
      wrapLines={true}
      sortingDisabled={true}
    />
  );
}

function TitleNode({ definition }: NodeProps) {
  const kind = definition.kind !== 'Property' ? definition.kind : null;
  return (
    <SpaceBetween size="xs" direction="horizontal">
      {definition.flags.map((flag: string) => (
        <Badge key={flag}>{flag}</Badge>
      ))}
      {kind && <div>{kind}</div>}
      {definition.name}
    </SpaceBetween>
  );
}

function CommentNode({ definition }: NodeProps) {
  return (
    <SpaceBetween size="m">
      <Markdown>{definition.markdown}</Markdown>
      {definition.tags.map((tag: any) => (
        <CommentTag key={tag.name} {...tag} />
      ))}
    </SpaceBetween>
  );
}

function CommentTag({ name, markdown }: { name: string; markdown: string }) {
  return (
    <SpaceBetween size="s">
      <Box fontWeight="bold">{name}</Box>
      <Markdown>{markdown}</Markdown>
    </SpaceBetween>
  );
}

function CodeNode({ definition, onNavigate }: NodeProps) {
  return (
    <Code>
      {definition.tokens.map(([value, kind, options]: any, index: number) => (
        <CodeToken key={index} kind={kind} options={options} onNavigate={path => onNavigate(buildUrl(path))}>
          {value}
        </CodeToken>
      ))}
    </Code>
  );
}

function LiteralNode({ definition }: NodeProps) {
  return definition.value;
}

function EmptyNode() {
  return <Box>-</Box>;
}

function buildUrl(path: string[]) {
  return path.filter(entry => !entry.startsWith('@')).join('#');
}
